// TODO: change to pascal naming

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  RATHER_NOT_SAY
}

enum LengthUnit {
  CM
  MM
  MTR
  FT
}

enum WeightUnit {
  KG
  LB
}

enum Goal {
  BODY_RECOMPOSITION
  STRENGTH
  KEEPING_FIT
  ATHLETICISM
  OTHERS
}

enum LevelOfExperience {
  BEGINNER
  MID
  ADVANCED
  EXPERT
}

enum ExcerciseMechanics {
  COMPOUND
  ISOLATED
}

enum ExcerciseForce {
  PUSH
  PULL
}

enum ExcerciseUtility {
  BASIC
  AUXILIARY
}

enum ExcerciseMetadataState {
  LEARNING
  INCREASED_DIFFICULTY
  DECREASED_DIFFICULTY
  MAINTAINENCE
}

enum Equipment {
  DUMBBELL
  BARBELL
  KETTLEBELL
  CABLE
  LEVER
  SUSPENSION
  T_BAR
  TRAP_BAR
  SLED
  SMITH
  BENCH
  MEDICINE_BALL
  PREACHER
  PARALLEL_BARS
  PULL_UP_BAR
  STABILITY_BALL
}

enum MuscleRegionType {
  HIPS
  UPPER_ARM
  SHOULDER
  WAIST
  CALVES
  THIGHS
  BACK
  CHEST
  FORE_ARM
  NECK
}

enum ExcerciseSetGroupState {
  DELETED_TEMPORARILY
  DELETED_PERMANANTLY
  REPLACEMENT_TEMPORARILY
  REPLACEMENT_PERMANANTLY
  NORMAL_OPERATION
}

enum WorkoutState {
  UNATTEMPTED
  IN_PROGRESS
  COMPLETED
  DRAFT
}

enum WorkoutType {
  AI_MANAGED
  SELF_MANAGED
  COACH_MANAGED
}

// FOR SETS ONLY (Affects their next workout sets, does not affect the current workout's sets)
// any set that fail will cause the rest time to increase by 1.25x for the next set. 
// This is effect temporary, will reset back to lower limit in the next workout
enum FailureReason {
  INSUFFICIENT_TIME // (Means that user this session need rush off) No change
  INSUFFICIENT_REST_TIME // Permanantly increases the lower limit of rest time by 1.25x
  TOO_DIFFICULT // Reduce rep (Or reduce weight if at lower limit of weight range)
  LOW_MOOD // (Means that user not enough motivation) No change
  INSUFFICIENT_SLEEP // (Means that user not enough sleep recently) No change
}

// // TODO: Use polymorphism. But prisma does not currently support this.
// // Contains the authentication information of the user.
model BaseUser {
  base_user_id Int    @id @default(autoincrement())
  email        String @unique
  firebase_uid String @unique
  displayName  String
  coach        Coach?
  User         User?
}

model Coach {
  // TODO: Add in more fields as we gain more requirements from gyms
  coach_id     Int       @id @default(autoincrement())
  base_user    BaseUser  @relation(fields: [base_user_id], references: [base_user_id], onDelete: Cascade)
  base_user_id Int       @unique
  Review       Review[]
  Program      Program[]
}

model Review {
  review_id Int    @id @default(autoincrement())
  coach     Coach  @relation(fields: [coach_id], references: [coach_id], onDelete: Cascade)
  rating    Float
  content   String
  coach_id  Int
}

model Program {
  program_id Int       @id @default(autoincrement())
  coach      Coach     @relation(fields: [coach_id], references: [coach_id], onDelete: Cascade)
  user       User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  workouts   Workout[]
  coach_id   Int
  user_id    Int
  is_active  Boolean   @default(true)
}

model User {
  user_id                           Int                 @id @default(autoincrement())
  base_user                         BaseUser            @relation(fields: [base_user_id], references: [base_user_id], onDelete: Cascade)
  prior_years_of_experience         Float?
  level_of_experience               LevelOfExperience?
  age                               Int?
  dark_mode                         Boolean             @default(false)
  automatic_scheduling              Boolean             @default(true)
  workout_frequency                 Int?
  workout_duration                  Int?
  goal                              Goal?
  gender                            Gender?
  weight                            Float?
  height                            Float?
  weight_unit                       WeightUnit?
  height_unit                       LengthUnit?
  phoneNumber                       String?
  compound_movement_rep_lower_bound Int                 @default(3)
  compound_movement_rep_upper_bound Int                 @default(10)
  isolated_movement_rep_lower_bound Int                 @default(5)
  isolated_movement_rep_upper_bound Int                 @default(15)
  body_weight_rep_lower_bound       Int                 @default(8)
  body_weight_rep_upper_bound       Int                 @default(20)
  workout_type_enrollment           WorkoutType         @default(SELF_MANAGED)
  base_user_id                      Int                 @unique
  ai_managed_workouts_life_cycle    Int                 @default(12)
  use_rpe                           Boolean             @default(false)
  equipment_accessible              Equipment[]
  measurements                      Measurement[]
  workouts                          Workout[]
  notifications                     Notification[]
  broadcasts                        BroadCast[]
  excerciseMetadata                 ExcerciseMetadata[]
  Program                           Program[]
}

model ExcerciseMetadata {
  excercise_metadata_state              ExcerciseMetadataState @default(LEARNING)
  user                                  User                   @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  excercise                             Excercise              @relation(fields: [excercise_name], references: [excercise_name], onDelete: Cascade)
  haveRequiredEquipment                 Boolean?
  preferred                             Boolean?
  last_excecuted                        DateTime?
  best_weight                           Float                  @default(0)
  weight_unit                           WeightUnit             @default(KG)
  best_rep                              Int                    @default(0)
  rest_time_lower_bound                 Int                    @default(90)
  rest_time_upper_bound                 Int                    @default(180)
  user_id                               Int
  excercise_name                        String
  estimated_historical_average_best_rep Int                    @default(0)
  estimated_historical_best_one_rep_max Float                  @default(0)

  @@id([user_id, excercise_name])
}

model Measurement {
  measurement_id    Int          @id @default(autoincrement())
  measured_at       DateTime
  muscle_region     MuscleRegion @relation(fields: [muscle_region_id], references: [muscle_region_id])
  measurement_value Float
  length_units      LengthUnit
  user              User         @relation(fields: [user_id], references: [user_id])
  user_id           Int
  muscle_region_id  Int
}

model Workout {
  workout_id           Int                 @id @default(autoincrement())
  workout_name         String
  user                 User                @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  life_span            Int
  order_index          Int // Keeps track of the order of workout
  date_scheduled       DateTime?
  date_completed       DateTime?
  performance_rating   Float?
  user_id              Int
  workout_state        WorkoutState        @default(UNATTEMPTED)
  workout_type         WorkoutType         @default(SELF_MANAGED)
  excercise_set_groups ExcerciseSetGroup[]
  Program              Program?            @relation(fields: [programProgram_id], references: [program_id], onDelete: Cascade) // Will only have a value if this is coach-managed. No choice because polymorphism not supported yet by prisma.
  programProgram_id    Int?
}

model ExcerciseSetGroup {
  excercise_set_group_id    Int                    @id @default(autoincrement())
  workout                   Workout                @relation(fields: [workout_id], references: [workout_id], onDelete: Cascade)
  excercise                 Excercise              @relation(fields: [excercise_name], references: [excercise_name], onDelete: Cascade)
  excercise_sets            ExcerciseSet[]
  excercise_name            String
  workout_id                Int
  excercise_set_group_state ExcerciseSetGroupState
  failure_reason            FailureReason?
}

model MuscleRegion {
  muscle_region_id           Int              @id @default(autoincrement())
  muscle_region_name         String           @unique
  muscle_region_description  String?
  muscle_region_type         MuscleRegionType
  stabilizer_muscles         Excercise[]      @relation(name: "stabilizer")
  dynamic_stabilizer_muscles Excercise[]      @relation(name: "dynamic")
  target_muscles             Excercise[]      @relation(name: "target")
  synergist_muscles          Excercise[]      @relation(name: "synergist")
  measurements               Measurement[]
}

model Excercise {
  excercise_name             String               @id
  excercise_preparation      String?
  excercise_instructions     String?
  excercise_tips             String?
  excercise_utility          ExcerciseUtility[]
  excercise_mechanics        ExcerciseMechanics[]
  excercise_force            ExcerciseForce[]
  target_regions             MuscleRegion[]       @relation(name: "target")
  stabilizer_muscles         MuscleRegion[]       @relation(name: "stabilizer")
  synergist_muscles          MuscleRegion[]       @relation(name: "synergist")
  dynamic_stabilizer_muscles MuscleRegion[]       @relation(name: "dynamic")
  equipment_required         Equipment[]
  body_weight                Boolean
  assisted                   Boolean
  excercise_set_groups       ExcerciseSetGroup[]
  excerciseMetadata          ExcerciseMetadata[]
}

model ExcerciseSet {
  excercise_set_id           Int               @id @default(autoincrement())
  target_weight              Float
  weight_unit                WeightUnit
  target_reps                Int
  actual_weight              Float?
  actual_reps                Int?
  rate_of_perceived_exertion Int?
  excerciseSetGroup          ExcerciseSetGroup @relation(fields: [excercise_set_group_id], references: [excercise_set_group_id], onDelete: Cascade)
  excercise_set_group_id     Int
}

model BroadCast {
  broad_cast_id     Int      @id @default(autoincrement())
  broadcast_message String
  users             User[]
  scheduled_start   DateTime
  scheduled_end     DateTime
}

model Notification {
  notification_id      Int    @id @default(autoincrement())
  notification_message String
  user                 User   @relation(fields: [user_id], references: [user_id])
  user_id              Int
}
